module inline-function-source-2
// File added by Loek

imports 
  statix/runtime/analysis
  libspoofax/ui/dialogs
  inline-function-name-fix

rules
  inline-function-action(pp-debug, ls-extract-data, ls-make-decs, ls-get-last-return, ls-is-return,
    ls-construct-block, ls-is-exp-language, ls-is-statement, ls-insert-before, ls-remove-exp,
    ls-fix-semantic-errors, editor-analyze
    |extension): (selected-term, _, ast, path, _) -> result
	 with // TODO: Replace with where
        // TODO: Replace filename with name of actual file instead of new file, such that the refactoring happens in the same file.
        filename := <guarantee-extension(|extension)> path // Filename to store new program in.
      ; inline-errors := <new-iset>
      ;(
        (
          new-ast := <scope-local-new(inline-function(ls-extract-data, ls-make-decs,
            ls-get-last-return, ls-is-return, ls-construct-block, ls-is-exp-language, 
            ls-is-statement, ls-insert-before, ls-remove-exp, ls-fix-semantic-errors, 
            editor-analyze
            |inline-errors))> (selected-term, ast)
        	; result := (filename, <pp-debug> new-ast)
        ) <+ (
          <display-errors> inline-errors
          ; result := None() // Errors occurred so don't change the program.
        )
      )
      ; <iset-destroy> inline-errors
      


  // Main strategy.
  inline-function(ls-extract-data, ls-make-decs, ls-get-last-return, ls-is-return, 
    ls-construct-block, ls-is-exp-language, ls-is-statement, ls-insert-before, ls-remove-exp,
    ls-fix-semantic-errors, editor-analyze
    |inline-errors): (selected-term, ast) -> ast-result
    where
      // Step 0 - Annotate Identifiers with unique IDs.
      // Annotate identifier Terms with their unique IDs for name fix.
      // Also store them in the set Vs.
        vs := <new-iset>
      // new-ids is needed to map the output of <stx-get-ast-ref> to the corresponding new term.
      ; new-ids := <new-hashtable>
      ; ast-s := 
          <topdown(try(is-string; generate-id(|vs, new-ids, NameFixID(<local-newname> "v"))))> ast
      
      
      // Step 1 - Find Definition and Extract Data.
      // We need to explore subterms of the selected-term in case the function call is wrapped by 
      // some constructor that is not covered by the ls-extract-data rules.
      ; (<oncetd((fun-call-term, fun-call-name, args) := <ls-extract-data(|())>)> selected-term
        <+ <add-error(|"ls-extract-data failed to find a function call term in the selected term", 
                        [("term", selected-term)])> inline-errors)
      // Ensure that the extracted terms are annotated with the correct IDs.
      ; fun-call-term' := <topdown(try(\ x -> <hashtable-get(|x)> new-ids \))> fun-call-term
      ; args' := <topdown(try(\ x -> <hashtable-get(|x)> new-ids \))> args
      
      // Get the scope graph.
      ; (analysis := <stx-get-ast-analysis>
        <+ <add-error(|"Something went wrong while retrieving the analysis of the AST.", [])> 
              inline-errors)
      
      // Get the referenced identifier term (which should belong to the function definition).
      // Because the term returned by stx-get-ast-ref is from the old ast, it doesn't have a
      // NameFixID annotation. Get the corresponding term from the hasthable new-ids.
      ; (fun-def-name := <hashtable-get(|
                            <get-ref-helper> <stx-get-ast-ref(|analysis)> fun-call-name
                         )> new-ids
        <+ <add-error(|"Something went wrong while querying the scope graph with the term below", 
                        [("term", fun-call-name)])> inline-errors)
            
      // Get the function definition data.
      ; ((params, body, ftype) := <collect-one(ls-extract-data(|fun-def-name))> ast-s
        <+ <add-error(|"ls-extract-data failed to find the function definition with the name term 
                        below when extracting the data", [("term", fun-def-name)])> inline-errors)
      // Annotate all identifiers inside the function definition with "original.
      ; (ast-s' := <oncetd(where(ls-extract-data(|fun-def-name)); 
                          !<topdown(try(is-string; !<add-annotation(|"original")>))>)> ast-s
        <+ <add-error(|"ls-extract-data failed to find function definition with the name term 
                        below when annotating the identifiers", [("term", fun-def-name)]
                     )> inline-errors)
            
      
      // Step 2 - Instantiate Parameters.
      ; param-decs := <ls-make-decs> (params, args')
      
      
      // Step 3 - Deal with Return Statements.
      // ls-get-last-return only extracts and removes a return statement if applicable in the 
      // language in question.
      ; ((body', return-exp) := <ls-get-last-return(|ftype)> body
        <+ <add-error(|"ls-get-last-return failed to extract the last return statement from the 
                        body below", body)> inline-errors)
      ; (<topdown(not(ls-is-return))> body'
        <+ <add-error(|"ls-is-return found return statements before the last statement in the 
                        function body", [("body", body)])> inline-errors)
      
      
      // Step 4 - Transform the AST.
      ; (block := <ls-construct-block> (body', param-decs)
        <+ <add-error(|"ls-construct-block failed to create a code block from the body and 
                        parameter declarations", [("body", body'), ("param-decs", param-decs)]
                     )> inline-errors)
      ; if ls-is-exp-language
        then ast-t := <oncetd(?fun-call-term'; !block)> ast-s'
        else 
          (surrounding-stmt := <get-surrounding-stmt(ls-is-statement|fun-call-term', ())> ast-s'
          <+ <add-error(|"No surrounding ls-is-statement term was found for the function call term 
                          in the ast", [("fun-call-term", fun-call-term'), ("AST", ast-s')]
                       )> inline-errors)
                
        ; (ast-t := <ls-insert-before(|surrounding-stmt, block)> ast-s'
          <+ <add-error(|"ls-insert-before failed to insert the block into the AST before the 
                          statement", [("block", block), ("stmt", surrounding-stmt), 
                          ("AST", ast-s')])> inline-errors)
        // If inlining is not allowed by the language engineer for the surrounding stmt (for
        // example because the call is surrounded by a loop-condition) the ast-t should be turned 
        // into () such that it is caught by the try() clause below.
        ; try(<eq> (ast-t, ()); <add-error(|"ls-insert-before returned an empty AST", [])> 
                                  inline-errors)
        
        ; if <eq> (return-exp, ())
          then (ast-t' := <ls-remove-exp(|fun-call-term')> ast-t
               <+ <add-error(|"ls-remove-exp failed to remove the function call", 
                              [("call", fun-call-term'), ("AST", ast-t)])> inline-errors)
          else (ast-t' := <oncetd(?fun-call-term'; !return-exp)> ast-t
               <+ <add-error(|"Failed to replace the function call with the return expression",
                              [("call", fun-call-term'), ("exp", return-exp), ("AST", ast-t)]
                            )> inline-errors)
          end
        end
      
      
      // Step 5 - Check and Fix Reference Relations.
      ; ast-result := <name-fix(editor-analyze, add-error, ls-fix-semantic-errors|
                        ast-s, analysis, vs, inline-errors, new-ids)> ast-t'
            
      ; <iset-destroy> vs
      ; <hashtable-destroy> new-ids        
        
        
  display-errors: inline-errors -> ()
    with
       all-error-strings := <concat-strings> <iset-elements> inline-errors
     ; <show-dialog(|"Inline Function Error", "Error")> all-error-strings

  add-annotation(|annotation): t -> <set-annotations> (t, [annotation | <get-annotations> t])

  generate-id(|vs, new-ids, v): t -> new-t
    where
        new-t := <add-annotation(|v)> t
      ; <iset-add(|v)> vs
      ; <hashtable-put(|t, new-t)> new-ids
      
  // In some languages the Ref() relation returns a list of terms instead of a single term.
  // If this is the case we assume that the first entry in the list is the correct definition.
  get-ref-helper: [t|_] -> t
  get-ref-helper: t -> t

  add-error(|msg, error-tuples): errors -> ()
    where
        <iset-add(|
          <concat-strings> 
            ["> ERROR: ", msg, ":",
            <concat-strings> <map(format-error-tuple)> error-tuples,
            "\n\n"]
        )> errors
      ; fail // After an error occurred, execution should abort so a fail is added.
  // We strip the annotations because otherwise the error message would become cluttered.
  format-error-tuple: (msg, t) 
    -> <concat-strings> ["\n\n    ", msg, ": ", <write-to-string> <strip-annos> t]
        
  // When the term itself is a statement, it is its own surrounding statement.
  get-surrounding-stmt(ls-is-statement|fun-call-term, _): _ -> fun-call-term
    where
      <ls-is-statement> fun-call-term
  // When the term is reached in the AST, the last-encountered statement is returned.
  get-surrounding-stmt(ls-is-statement|fun-call-term, last-stmt): fun-call-term -> last-stmt
  // When a deeper statement is reached, it is stored as the last-encountered statement.
  get-surrounding-stmt(ls-is-statement|fun-call-term, last-stmt): t -> result
    where
        <ls-is-statement> t
      ; <one(get-surrounding-stmt(ls-is-statement|fun-call-term, t); ?result)> t
  // When neither of the above cases apply, the current term is simply skipped.
  get-surrounding-stmt(ls-is-statement|fun-call-term, last-stmt): t -> result
    where
      <one(get-surrounding-stmt(ls-is-statement|fun-call-term, last-stmt); ?result)> t
        
        
      