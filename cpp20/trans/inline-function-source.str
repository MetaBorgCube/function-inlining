module inline-function-source
// File added by Loek

imports 
  statixruntime
  statix/api
  statix/runtime/renaming

rules  
  inline-function-action(find-call, get-subterms-from-call, get-subterms-from-definition, 
  						 get-subterms-from-argument, get-term-from-name, make-variable, 
  						 editor-analyze, pp-debug, insert-block | extension):
    (t, _, ast, path, _) -> (filename, result)
    with 
        filename := <guarantee-extension(|extension)> path // Filename to store new program in.
      ; new-ast := <inline-function(find-call, get-subterms-from-call, get-subterms-from-definition, get-subterms-from-argument, 
                         get-term-from-name, make-variable, editor-analyze, pp-debug, insert-block)> (t, ast)
      ; result := <pp-debug> new-ast

  inline-function(find-call, get-subterms-from-call, get-subterms-from-definition, get-subterms-from-argument, 
                         get-term-from-name, make-variable, editor-analyze, pp-debug, insert-block):
    (t, ast) -> ast-reannotated
    with
      // In some languages the call term can be nested in the selected term. Extract it. 
	    selected := <find-call> t

      // Get the scope graph.
      ; analysis := <stx-get-ast-analysis> selected
      
      // Extract the name- and the argument subterms from the function call term.
      ; (function-name, args) := <get-subterms-from-call> selected
      
      // Find and extract the function definition.
      ; definition-name := <get-ref-helper> (<stx-get-ast-ref(|analysis)> function-name) // Get definition name term from Ref().
      ; definition-term := <collect-one(get-term-from-name(|definition-name))> ast // Get encapsulating definition term.
      ; (params, type, body) := <get-subterms-from-definition> definition-term // Extract required subterms.
      
      // Set up reference annotations.
      ; refs := <new-hashtable> // Maps definition terms to an annotation they are meant to receive. Can be updated dynamically.
      ; body-annotated := <topdown(try(annotate-definition(|refs)))> (<topdown(try(get-ref-relation(|analysis, params, refs)))> body)
      ; new-vars := <declare-parameters(get-subterms-from-argument, make-variable|refs)> (args, params) // Define variables for arguments.
      ; ast-annotated := <topdown(try(annotate-definition(|refs)))> ast
      ; <hashtable-destroy> refs
              
      ; ast-inlined := <insert-block(|selected, new-vars, body-annotated, type)> ast-annotated
            
      // Re-analyze the AST.
      // This uses a function implemented by Phil for Renaming.      
      ; <getfirst(?TermIndex(path, _))> <get-annotations> t
      ; ([(_, ast-reannotated)], new-analysis) := <rerun-analysis-single(editor-analyze)> [(path, (), ast-inlined)]
      
      // Check if reference annotations have been preserved.
      ; <topdown(check-ref-preservation(|new-analysis))> ast-reannotated
  
    
  
  // In some languages the Ref() relation returns a list of terms instead of a single term.
  // If this is the case we assume that the first entry in the list is the correct definition.
  get-ref-helper: [t|_] -> t
  get-ref-helper: t -> t
  
  get-ref-relation(|analysis, params, refs): t -> <add-annotation> (t, annotation)
    where
        definition := <get-ref-helper> (<stx-get-ast-ref(|analysis)> t)
      ; if not(annotation := <hashtable-get(|definition)> refs)
          then annotation := <newname> "ref"
             ; <hashtable-put(|definition, annotation)> refs
          end
  
  annotate-definition(|refs): t -> <add-annotation> (t, annotation)
    where
        annotation := <hashtable-get(|t)> refs
      ; <hashtable-remove(|t)> refs
  
  add-annotation: (t, annotation) -> <set-annotations> (t, <concat> [<get-annotations> t, [annotation]])
  
  check-ref-preservation(|analysis): t -> t
    where
      if annotation := <fetch-elem(string-starts-with(|"ref"))> (<get-annotations> t)
       ; definition := <get-ref-helper> (<stx-get-ast-ref(|analysis)> t)
        then <elem> (annotation, <get-annotations> definition)
        end
  
  
  
  // Creates a list of definition terms for the arguments of the function call.
  declare-parameters(get-subterms-from-argument, make-variable|refs): ([], []) -> []
  declare-parameters(get-subterms-from-argument, make-variable|refs): ([a|args], [p|params]) -> variables
    with
        (n, type) := <get-subterms-from-argument> p
      ; name := <oncetd(annotate-definition(|refs)) <+ id> n
      ; variables := [<make-variable> (name, type, a) | <declare-parameters(get-subterms-from-argument, make-variable|refs)> (args, params)]
  
  
  