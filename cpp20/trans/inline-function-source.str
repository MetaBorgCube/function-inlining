module inline-function-source
// File added by Loek

imports 
  statixruntime
  statix/api
  statix/runtime/renaming

rules  
  inline-function-action(find-call, get-subterms-from-call, get-subterms-from-definition, 
    get-subterms-from-argument, get-term-from-name, make-variable, editor-analyze, pp-debug, 
    insert-block, error-msg-rename | extension): (t, _, ast, path, _) -> (filename, result)
    with 
        filename := <guarantee-extension(|extension)> path // Filename to store new program in.
      ; new-ast := <scope-local-new(inline-function(find-call, get-subterms-from-call, get-subterms-from-definition, get-subterms-from-argument, 
                         get-term-from-name, make-variable, editor-analyze, pp-debug, insert-block, error-msg-rename))> (t, ast)
      ; result := <pp-debug> new-ast

  inline-function(find-call, get-subterms-from-call, get-subterms-from-definition, 
    get-subterms-from-argument, get-term-from-name, make-variable, editor-analyze, pp-debug, 
    insert-block, error-msg-rename):
    (t, ast) -> ast-result
    where      
      // In some languages the call term can be nested in the selected term. Extract it.
      // Note: if you select a full expression, it will select the first call in the expression.
      // Not selecting anything will result in the first call in the program.
	    selected := <find-call> t

      // Get the scope graph.
      ; analysis := <stx-get-ast-analysis> selected
      
      // Extract the name- and the argument subterms from the function call term.
      ; (function-name, args, namespace) := <get-subterms-from-call> selected
      
      // Find and extract the function definition.
      ; definition-name := <get-ref-helper> (<stx-get-ast-ref(|analysis)> function-name) // Get definition name term from Ref().
      ; definition-term := <collect-one(get-term-from-name(|definition-name))> ast // Get encapsulating definition term.
      ; (params, type, body) := <get-subterms-from-definition> definition-term // Extract required subterms.
      
      //--- Set up annotations for name binding check at the end.
      ; refs := <new-hashtable> // Maps definition terms to corresponding unique annotation.
      ; body-annotated1 := <topdown(try(map-referenced-definitions(|analysis, params, refs)))> body
      ; body-annotated2 := <topdown(try(annotate-definitions(|refs)))> body-annotated1
      ; params-annotated1 := <declare-parameters(get-subterms-from-argument, make-variable|refs)> (args, params)
	  // Now that individual references in the body and parameters have been annotated, add a general annotation to all inlined terms.
      ; annotation1 := <newname> "inlined_"
      ; params-annotated2 := <topdown(add-annotation(|annotation1))> params-annotated1
      ; body-annotated3 := <topdown(add-annotation(|annotation1))> body-annotated2
      ; <hashtable-destroy> refs
      //--- Finished setting up annotations.
      
      // Inline the function definition.
      ; ast-inlined := <insert-block(|selected, params-annotated2, body-annotated3, type)> ast
            
      // Re-analyze the AST.
      ; <getfirst(?TermIndex(path, _))> <get-annotations> t
      ; Full(ast-reannotated, FileAnalysis(_, new-analysis), analysis-errors, _, _) := <re-analyze-ast-single(editor-analyze|path, analysis)> ast-inlined
	  	   
      // Check if reference annotations have been preserved.
      ; to-be-renamed := <new-hashtable> // Will be used to store unique annotations of inlined terms that need to be renamed.
	  ; <list-loop(try(erronous-inlined-definition(error-msg-rename|to-be-renamed, annotation1)))> analysis-errors // If there are analysis errors with inlined definitions, try renaming them to fix it.
      ; <topdown(check-ref-preservation(|to-be-renamed, new-analysis, annotation1))> ast-reannotated
      ; ast-result := <topdown(try(fix-capture(|to-be-renamed)))> ast-reannotated
      ; <hashtable-destroy> to-be-renamed      
  
    
  
  // In some languages the Ref() relation returns a list of terms instead of a single term.
  // If this is the case we assume that the first entry in the list is the correct definition.
  get-ref-helper: [t|_] -> t
  get-ref-helper: t -> t

  add-annotation(|annotation): t -> <set-annotations> (t, <concat> [<get-annotations> t, [annotation]])
 
  map-referenced-definitions(|analysis, params, refs): t -> <add-annotation(|annotation)> t
    where
        definition := <get-ref-helper> (<stx-get-ast-ref(|analysis)> t)
      ; if not(annotation := <hashtable-get(|definition)> refs)
          then annotation := <newname> "ref"
             ; <hashtable-put(|definition, annotation)> refs
          end
  
  annotate-definitions(|refs): t -> <add-annotation(|<conc-strings> ("d", annotation))> t
    where
        annotation := <hashtable-get(|t)> refs
      ; <hashtable-remove(|t)> refs

  
  // Creates a list of definition terms for the arguments of the function call.
  declare-parameters(get-subterms-from-argument, make-variable|refs): ([], []) -> []
  declare-parameters(get-subterms-from-argument, make-variable|refs): ([a|args], [p|params]) -> variables
    with
        (n, type) := <get-subterms-from-argument> p
      ; name := <oncetd(annotate-definitions(|refs) <+ (is-string ; add-annotation(|<newname> "dref")))> n  // Adds annotation for name binding checks.
      ; variables := [<make-variable> (name, type, a) | <declare-parameters(get-subterms-from-argument, make-variable|refs)> (args, params)]

  re-analyze-ast-single(editor-analyze|path, old-analysis): ast -> result
    where
        input := AnalyzeSingle([(path, Changed(ast, old-analysis))], (), ())
      ; AnalysisResult([(_, result)]) := <editor-analyze> input
  
  check-ref-preservation(|to-be-renamed, analysis, annotation): t -> t
    where
      // If the term references an inlined definition, the term itself should be inlined too (marked with 'annotation').
        if definition-name := <get-ref-helper> (<stx-get-ast-ref(|analysis)> t)
          ; <elem> (annotation, <get-annotations> definition-name)
        then (<elem> (annotation, <get-annotations> t)
          // If the current term is NOT inlined, we store the annotation of the referenced definition for renaming.
          <+ (annotation2 := <fetch-elem(string-starts-with(|"dref"))> (<get-annotations> definition-name)
            ; <hashtable-put(|annotation2, <local-newname> t)> to-be-renamed
            ))
        end
      // If the term has an annotation starting with "ref" (which should only be the case for inlined terms), 
      // then the referenced term should have the corresponding "dref" annotation.
      // (meaning the correct definition is referenced)
      ; if annotation3 := <fetch-elem(string-starts-with(|"ref"))> (<get-annotations> t)
        then definition-name := <get-ref-helper> (<stx-get-ast-ref(|analysis)> t) 
           ; <elem> (<string-replace(|"ref", "dref")> annotation3, <get-annotations> definition-name)
        end
  
  // If an analysis error contains an annotation indicating that it is inlined ("inlined_x"),
  // store it for renaming.
  erronous-inlined-definition(error-msg-rename|to-be-renamed, a): (term, error) -> ()
    where
	    <error-msg-rename> error
	  ; annotations := <get-annotations> term
	  ; <elem> (a, annotations)
	  ; if annotation := <fetch-elem(string-starts-with(|"dref"))> annotations 
	    then <hashtable-put(|annotation, ())> to-be-renamed
	    else termindex := <fetch-elem(?TermIndex(_, _))> annotations
	      ; <hashtable-put(|termindex, ())> to-be-renamed
	    end
  
  // Renames all terms whose annotation has been marked to be renamed.
  fix-capture(|to-be-renamed): t -> new-t
    where
        annotations := <get-annotations> t
      // Check if the current term has a "dref"/"ref" annotation.
      ; if (annotation := <fetch-elem(string-starts-with(|"dref"))> annotations
          <+ annotation := <conc-strings> ("d", <fetch-elem(string-starts-with(|"ref"))> annotations))
        // Check if the term should be renamed (then the annotation is in the hashtable). 
        then new-name := <hashtable-get(|annotation)> to-be-renamed
          // Check if a replacement name has been created yet. If not, create and store a new one.
          ; if <is-string> new-name
            then new-t := new-name
            else new-t := <local-newname> t
              ; <hashtable-put(|annotation, new-t)> to-be-renamed
            end
        // Check if the termindex is stored for renaming
        else termindex := <fetch-elem(?TermIndex(_, _))> annotations
          ; <hashtable-get(|termindex)> to-be-renamed
          ; new-t := <local-newname> t // When the termindex is stored, the new term name has not been generated yet.
        end
  
  
  