module inline-function/name_binding_fix

language cpp20

/*
Tests the rename fix for conflicting inlined definitions
*/

test rename duplicate definition when both are used [[
int increment(int x) {
    return x + 1;
}

int main() {
    int x = 5;
    [[increment(2)]];
    x = 6;
}
]] run inline-function-test(|#1) to [[
int increment(int x)
{
  return x + 1;
}

int main( )
{
  int x = 5;
  int x_0 = 2;
  x_0 + 1;
  x = 6;
}
]]

test rename duplicate definition when original definition is unused [[
int increment(int x) {
    return x + 1;
}

int main() {
    int x = 5;
    [[increment(2)]];
}
]] run inline-function-test(|#1) to [[
int increment(int x)
{
  return x + 1;
}

int main( )
{
  int x = 5;
  int x_0 = 2;
  x_0 + 1;
}
]]

test rename duplicate definition when inlined definition is unused [[
int increment(int x) {
    return 1;
}

int main() {
    int x = 5;
    [[increment(2)]];
    x = 2;
}
]] run inline-function-test(|#1) to [[
int increment(int x)
{
  return 1;
}

int main( )
{
  int x = 5;
  int x_0 = 2;
  1;
  x = 2;
}
]]

test rename duplicate definition when both are unused (parameter) [[
int increment(int x) {
    return 1;
}

int main() {
    int x = 5;
    [[increment(2)]];
}
]] run inline-function-test(|#1) to [[
int increment(int x)
{
  return 1;
}

int main( )
{
  int x = 5;
  int x_0 = 2;
  1;
}
]]

test rename duplicate definition when both are unused (explicit definition) [[
int increment() {
	int x;
    return 1;
}

int main() {
    int x = 5;
    [[increment()]];
}
]] run inline-function-test(|#1) to [[
int increment()
{
  int x;
  return 1;
}

int main( )
{
  int x = 5;
  int x_0;
  1;
}
]]

// Test: when a parameter is unused in the body it still gets an inlined definition. What if that definition captures a variable?

// Test: when an unused definition in the body is inlined, what happens when that definition captures a variable?
// (only definitions that get referenced currently receive a unique annotation, which is required for the rename fix of capture.)